;;;; this is dinero
;;;; copyright 2001 Josiah Barber
;;;; released under the terms and conditions of the GNU GPL


;;;; TODO:
;;;;  editing fields
;;;;  adding and displaying total
;;;;    -- which uses a function that adds total for a certain range
;;;;  writing to file



;;;; interface to curses library
(load-1-foreign "/lib/libncurses.so.5.2")

(def-alien-routine initscr void)
;;int keypad(WINDOW *win, bool bf);
(def-alien-routine keypad int (win int) (bf char))

(def-alien-routine cbreak int)
(def-alien-routine noecho int)
(def-alien-routine raw int)
(def-alien-routine refresh int)
(def-alien-routine endwin int)
(def-alien-routine erase int)
(def-alien-routine move int (y int) (x int))
(def-alien-routine ("addch" curses-addch) int (ch char))

(defun addch (c)
  (curses-addch (char-code c)))

(def-alien-routine ("getch" curses-getch) int)

(defun getch ()
  (let ((c (curses-getch)))
	(if (or (< c 0)
			(> c 256))
		c
		(code-char c))))

;;int addstr(const char *str);
(def-alien-routine addstr int (str c-string))

(def-alien-routine attrset void (attrs int))

;;int innstr(char *str, int n);
(def-alien-routine ("innstr" curses-innstr) int (str c-string) (n int))

(defun innstr (n)
  (with-alien ((buf (array char 1024)))
	(curses-innstr (cast buf (* char)) n)
	(cast buf c-string)))

;;; attributes
(defconstant A_NORMAL     #x00000000)
(defconstant A_STANDOUT   #x00010000)
(defconstant A_UNDERLINE  #x00020000)
(defconstant A_REVERSE    #x00040000)
(defconstant A_BLINK      #x00080000)
(defconstant A_DIM        #x00100000)
(defconstant A_BOLD       #x00200000)
(defconstant A_ALTCHARSET #x00400000)
(defconstant A_INVIS      #x00800000)

(defconstant A_PROTECT    #x01000000)
(defconstant A_HORIZONTAL #x02000000)
(defconstant A_LEFT       #x04000000)
(defconstant A_LOW        #x08000000)
(defconstant A_RIGHT      #x10000000)
(defconstant A_TOP        #x20000000)
(defconstant A_VERTICAL   #x40000000)

;;; keys
(defconstant KEY_MIN        #o401)
(defconstant KEY_DOWN       #o402)
(defconstant KEY_UP         #o403)
(defconstant KEY_LEFT       #o404)
(defconstant KEY_RIGHT      #o405)
(defconstant KEY_HOME       #o406)
;(defconstant KEY_BEG        #o542)
(defconstant KEY_BACKSPACE  #o407)
(defconstant KEY_NPAGE      #o522)
(defconstant KEY_PPAGE      #o523)
(defconstant KEY_END        #o550)
;(defconstant KEY_LL         #o533)
;;;; end curses interface

;;;; unix interface
; int raise (int sig);
(def-alien-routine raise int (sig int))

; pid_t getpid(void);
(def-alien-routine getpid int)

; pid_t getppid(void);
(def-alien-routine getppid int)

; int kill(pid_t pid, int sig);
(def-alien-routine kill int (pid int) (sig int))

(defconstant SIGSTOP 19)
;;;; end unix interface

(defvar *date-width* 10 "width of the date field")
(defvar *money-width* 10 "width of the money field")

(defvar *cur-line* 0)
(defvar *cur-col* 0)
(defvar *line-offset* 0 "number of lines not shown above top of screen")

(defstruct entry
  date
  comment
  money)

(defvar *account* '() "list of entries that make up the account")

(defun control-key (c)
  "returns the code that would be generated by pressing Ctrl-`C'."
  (code-char (- (char-code (char-upcase c)) 64)))

(defun normal-charp (c)
  "returns t if `C' is a normal, printable character."
  (and (characterp c)
	   (>= (char-code c) 32)
	   (<= (char-code c) 126)))

(defvar *key-bindings*
  (list (cons KEY_LEFT 'move-left)
		(cons KEY_RIGHT 'move-right)
		(cons KEY_UP 'move-up)
		(cons KEY_DOWN 'move-down)
		(cons (control-key #\b) 'move-left)
		(cons (control-key #\f) 'move-right)
		(cons (control-key #\p) 'move-up)
		(cons (control-key #\n) 'move-down)
		(cons (control-key #\j) 'edit-field)))

(defun my-refresh ()
  (let ((cols (extern-alien "COLS" int))
		(lines (extern-alien "LINES" int)))
	(attrset A_REVERSE)
	(clear-line (- lines 2))
	(move (- lines 2) 0)
	(addstr (format nil "----L~A--B~A" (+ *cur-line* *line-offset* 1) (length *account*)))
	(attrset A_NORMAL)
	(move (- lines 1) (- cols 1))
	(refresh)))

(defun update-screen ()
  (let ((line 0)
		(cols (extern-alien "COLS" int))
		(lines (extern-alien "LINES" int)))
	(erase)
	(dolist (this-entry (subseq *account* *line-offset*))
	  (if (>= (- line 1) (- lines 3))
		  (return))
	  (if this-entry
		  (progn
			(move line 0)
			(addstr (entry-date this-entry))
			(move line (+ *date-width* 1))
			(addstr (entry-comment this-entry))
			(move line (- cols *money-width*))
			(addstr (entry-money this-entry))))
	  (incf line))
	(set-field-attrib *cur-line* *cur-col* A_REVERSE)))

(defun set-field-attrib (y x attrib)
  (let (in-buf field-length (cols (extern-alien "COLS" int)))
	(cond ((= x 0)
		   (setf field-length *date-width*))
		  ((= x 1)
		   (setf field-length (- cols *date-width* 1 *money-width* 2))
		   (incf x *date-width*))
		  ((= x 2)
		   (setf field-length *money-width*)
		   (setf x (- cols *money-width*))))
	(move y x)
	(setf in-buf (innstr field-length))
	(attrset attrib)
	(addstr in-buf)
	(attrset A_NORMAL)))

(defun clear-line (y)
  (let ((cols (extern-alien "COLS" int)))
	(move y 0)
	(dotimes (crap-variable cols)
	  (addch #\Space))))

(defun move-cursor (dir)
  (let ((lines (extern-alien "LINES" int)))
	(set-field-attrib *cur-line* *cur-col* A_NORMAL)
	(case dir
	  (up
	   (cond ((> *cur-line* 0)
			  (decf *cur-line*))
			 ((> *line-offset* 0)
			  (decf *line-offset*)
			  (update-screen))))
	  (down
	   (cond ((< *cur-line* (- lines 3))
			  (incf *cur-line*))
			 (t
			  (incf *line-offset*)
			  (update-screen))))
	  (left
	   (if (> *cur-col* 0)
		   (decf *cur-col*)
		   (cond ((> *cur-line* 0)
				  (decf *cur-line*)
				  (setf *cur-col* 2))
				 ((> *line-offset* 0)
				  (decf *line-offset*)
				  (setf *cur-col* 2)
				  (update-screen)))))
	  (right
	   (if (< *cur-col* 2)
		   (incf *cur-col*)
		   (cond ((< *cur-line* (- lines 3))
				  (incf *cur-line*)
				  (setf *cur-col* 0))
				 (t
				  (incf *line-offset*)
				  (setf *cur-col* 0)
				  (update-screen))))))
	(set-field-attrib *cur-line* *cur-col* A_REVERSE)
	(my-refresh)))

(defun read-account-from-file (file-name)
  (let (blanks date comment money temp-entry (temp-account nil))
	(with-open-file (stream file-name
							:direction :input
							:if-does-not-exist nil)
	  (when (null stream)
		(return-from read-account-from-file nil))
	  (loop
	   (setf blanks (read stream nil 'eof))
	   (if (eql blanks 'eof)
		   (return (setf *account* (reverse temp-account)))
		   (dotimes (crap (1- blanks))
			 (push nil temp-account)))
	   
	   (setf temp-entry (make-entry))

	   (setf date (read-line stream nil 'eof))
	   (when (eql date 'eof)
		 (return nil))
	   (setf (entry-date temp-entry) date)

	   (setf comment (read-line stream nil 'eof))
	   (when (eql comment 'eof)
		 (return nil))
	   (setf (entry-comment temp-entry) comment)

	   (setf money (read-line stream nil 'eof))
	   (when (eql money 'eof)
		 (return nil))
	   (setf (entry-money temp-entry) money)
	   (push temp-entry temp-account)))))

(defun suspend ()
  (endwin)
  (kill (getppid) SIGSTOP)
  (my-refresh))

(defun move-left ()
  (move-cursor 'left))

(defun move-right ()
  (move-cursor 'right))

(defun move-up ()
  (move-cursor 'up))

(defun move-down ()
  (move-cursor 'down))

(defun get-input (str)
  (let (c (c-lst (reverse (coerce str 'list))))
	(loop
	 (setf c (getch))
	 (cond ((eql c (control-key #\G))
			(return nil))
		   ((eql c (control-key #\J))
			(return (coerce (nreverse c-lst) 'string)))
		   ((not (normal-charp c))
;			(addstr (format nil "~A" c))
			)
		   (t
			(addch c)
			(push c c-lst)
			(refresh))))))

(defun edit-field ()
  (let* ((lines (extern-alien "LINES" int))
		(line (+ *cur-line* *line-offset*))
		(temp-entry (or (nth line *account*) (make-entry))))
	(move (1- lines) 0)
	(case *cur-col*
	  (0
	   (addstr "Date: ")
	   (when temp-entry (addstr (entry-date temp-entry)))
	   (refresh)
	   (setf (entry-date temp-entry)
			 (if temp-entry
				 (get-input (entry-date temp-entry))
				 (get-input nil)))
	   (when (entry-date temp-entry)
		 (when (> (+ line 1) (list-length *account*))
		   (setf *account* (append *account* (make-list (- (+ line 1) (list-length *account*))))))
		 (if (null (elt *account* line))
			 (setf (nth line *account*) temp-entry)
			 (setf (entry-date (nth line *account*)) (entry-date temp-entry)))))
	  (1
	   (addstr "Comment: ")
	   (when temp-entry (addstr (entry-comment temp-entry)))
	   (refresh)
	   (setf (entry-comment temp-entry)
			 (if temp-entry
				 (get-input (entry-comment temp-entry))
				 (get-input nil)))
	   (when (entry-comment temp-entry)
		 (when (> (+ line 1) (list-length *account*))
		   (setf *account* (append *account* (make-list (- (+ line 1) (list-length *account*))))))
		 (if (null (elt *account* line))
			 (setf (nth line *account*) temp-entry)
			 (setf (entry-comment (nth line *account*)) (entry-comment temp-entry)))))
	  (2
	   (addstr "Money: ")
	   (when temp-entry (addstr (entry-money temp-entry)))
	   (refresh)
	   (setf (entry-money temp-entry)
			 (if temp-entry
				 (get-input (entry-money temp-entry))
				 (get-input nil)))
	   (when (entry-money temp-entry)
		 (when (> (+ line 1) (list-length *account*))
		   (setf *account* (append *account* (make-list (- (+ line 1) (list-length *account*))))))
		 (if (null (elt *account* line))
			 (setf (nth line *account*) temp-entry)
			 (setf (entry-money (nth line *account*)) (entry-money temp-entry))))))
	(clear-line (1- lines))
	(update-screen)
	(my-refresh)))

(defun main-input-loop ()
  (let (c f)
	(loop
	 (setf c (getch))
	 (setf f (assoc c *key-bindings*))
	 (cond ((eql c (control-key #\C))
			(return))
		   ((eql c (control-key #\Z))
			(suspend))
		   ((consp f)
			(funcall (cdr f)))
		   ((numberp c)						;; miscellaneous key such as home, end, insert, F3, etc.
			(addch #\#)						;;  that can't be sent to addch
			(my-refresh))
;		   ((eql c #\k)
;			(setf *key-bindings*
;				  (cons (cons KEY_DOWN 'move-up)
;						(remove (assoc KEY_DOWN *key-bindings*) *key-bindings*)))
;			(setf *key-bindings*
;				  (cons (cons KEY_UP 'move-down)
;						(remove (assoc KEY_UP *key-bindings*) *key-bindings*))))
;		   ((eql c #\K)
;			(setf *key-bindings*
;				  (cons (cons KEY_DOWN 'move-down)
;						(remove (assoc KEY_DOWN *key-bindings*) *key-bindings*)))
;			(setf *key-bindings*
;				  (cons (cons KEY_UP 'move-up)
;						(remove (assoc KEY_UP *key-bindings*) *key-bindings*))))
;		   ((eql c #\c)
;			(clear-line 13)
;			(my-refresh))
;		   ((eql c #\z)
;			(push (make-entry :date "10/10/2001" :comment "este esta un coment") *account*)
;			(update-screen)
;			(my-refresh))
		   ((eql c #\x)
			(push (make-entry :date "10/11/2001" :comment "this is an english comment" :money "100.01") *account*)
			(update-screen)
			(my-refresh))
;		   ((eql c #\c)
;			(push nil *account*)
;			(update-screen)
;			(my-refresh))
		   ((eql c #\r)
			(read-account-from-file "a-file")
			(update-screen)
			(my-refresh))
		   (t
			(addch c)
			(my-refresh))))))

;;;; execution starts here
(initscr)
(keypad (extern-alien stdscr int) 1)
(cbreak)
(noecho)
(raw)

(set-field-attrib *cur-line* *cur-col* A_REVERSE)
(my-refresh)

(main-input-loop)

(endwin)
(quit)
